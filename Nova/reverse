reverse (<List E> ls)
  rec (prev = void, next = ls)
    if next
      rec (next.cdr := prev, next.cdr)
      else
      prev the <List E>

reverse ({E} seq) = (start, end) = seq.(start, end)
                    rec (seq' = seq #l (length of seq), i = 0)
                      if i >= #end (#l - i)
                        seq'
                        else
                        rec (seq'@(i,#end) := seq@(#end,i), i + 1)

reverse ([E] tab) = intermediate [E] modifying (tab)
                    (bind #arr   (lw #tab)
                          #size  (lw (add #tab 1))
                          #start 0
                          #end   (sub #size 1))
                    (label start)
                    (jif (ge #start #end) end)
                    (bind #temp (lw (add #arr #start)))
                    (sw (add #arr #start) (lw (add #arr #end))
                        (add #arr #end)   #temp)
                    (set #start (add #start 1)
                         #end   (sub #end 1))
                    (unbind #temp)
                    (jump start)
                    (label end)
                    (return (tuple #arr #size))

reverse ([E] tab) = to = array #size tab.size
                    intermediate [E] writing (to)
                    (bind #from (lw #tab)
                          #i    0
                          #end  (add #from (sub #size 1)))
                    (label start)
                    (jif (eq #i #size) end)
                    (sw (add #to #i) (lw (sub #end #i)))
                    (jump start)
                    (label end)
                    (return (tuple #to #size))
