struct Cons E
    E   car
    {E} cdr

Union List E = Cons E, Void

Cons E (E elt) : ({E} rest)
  cons (elt, rest)

{E} ({E} a) ++ ({E} b)
  tcase b
    Void -> a
  foldr (`:`, b, a)

E ({E} ls) ! (Int i)
  tcase ls
    Void   -> error "Index out of scope"
    Cons E -> if i == 0 -> ls.car
                 true -> ls.cdr ! (i - 1)

infixl 5 !!
{E} ({E} ls) !! (Int n)
  if n == 0 -> ls
     else   -> tcase ls
                 Void -> error "Index of out scope"
                 Cons E -> ls.cdr !! n - 1

Bool all (Bool <- E fn, {E} ls)
  tcase ls
    Void -> true
    Cons E -> fn ls.car
              all (fn,ls.cdr)

(E | Void) (K key) `assoc` ({(K,E)} alist)
  tcase alist
    Void       -> void
    Cons (K,E) -> node = alist.car
                  if key == 1of2 node -> 2of2 node
                     true -> key `assoc` alist.cdr

{E} circle ({E} ls)
  ncircle << foldr (`:`, {}, ls)

{E} conc ({{E}} lss)
  tcase lss
    Void   -> void
    Cons E -> lss.car ++ conc lss.cdr

{E} drop (Int n, {E} ls)
  if n == 0 -> ls
     true -> tcase ls
               Void   -> void
               Cons E -> drop (n - 1, ls.cdr)

{E} dropWhile (Bool <- E fn, {E} ls)
  tcase ls
    Void   -> void
    Cons E -> if fn ls.car -> dropWhile (fn, ls.cdr)
                 true -> ls

{E} filter (Bool <- E fn, {E} ls)
  tcase ls
    Void   -> void
    Cons E -> if fn ls.car -> ls.car : filter (fn, ls.cdr)
                 true -> filter (fn, ls.cdr)

(E | Void) find (I id, {E} ls, I <- E fn)
  tcase ls
    Void -> void
    Cons E -> if id == fn ls.car -> ls.car
                 else -> find (id, ls.cdr, fn)

A foldl (A <- (A,B) fn, A start, [B] ls)
  tacse ls
    Void   -> start
    Cons E -> foldl (fn, fn (start, ls.car), ls.cdr)

A foldr (A <- (B,A) fn, A start, [B] ls)
  tcase ls
    Void   -> start
    Cons B -> fn (ls.car, foldr (fn, start, ls.cdr))

{E} fromThen (E a, E b)
  E diff = b - a
  a : b : @rec (E c = b + diff)
            c : delay rec (c + diff)

{E} fromThenTo (E a, E b, E stop)
  E diff = b - a
  a : b : @rec (E c = b + diff)
            if c > stop -> void
               true -> c : rec (c + diff)

E head ({E} ls)
  tcase ls
    Void   -> error "Didn't expect an empty list"
    Cons E -> ls.car

Bool (E elt) `in` ({E} ls)
  member (elt,ls,id)

Bool member (A id, {E} ls, A <- E fn)
  tcase ls
    Void -> false
    Cons E -> if id == fn ls.car -> true
                 else -> member (id,ls.cdr,fn)


{E} intersect ({{E}} lss}
  intersectOn (id,lss)

{E} intersectOn (A <- E fn, {{E}} lss)
  if length lss == 1 -> head lss
     else -> @loop ({{E}} lss0 = lss)
               tcase lss0
                 Void -> void
                 Cons E -> @build ({E} ls = lss0.car)
                             tcase ls
                               Void -> loop lss0.cdr
                               Cons E -> E elt = ls.car
                                         if all (member (fn elt,#1,fn),lss) -> elt : build ls.cdr
                                            else -> build ls.cdr

Cons E last ({E} ls)
  tcase ls
    Void -> error "Empty list"
    Cons E -> @loop (Cons E ls = ls)
                nxt = ls.cdr
                tcase nxt
                  Void -> ls
                  Cons E -> loop nxt

Int length ({E} ls)
  tcase ls
    Void   -> 0
    Cons E -> 1 + length ls.cdr

{B} map (B <- A fn, {A} ls)
  tcase ls
    Void   -> void
    Cons E -> fn ls.car : map (fn, ls.cdr)

{B} mapConc = nconc `compose` map

{B} map2 (B <- (A,A) fn, {A} ls)
  match ls
    (a:b:_) -> (a `fn` b) : map2 (fn,ls.cdr)
    _       -> void

{B} map2 (B <- (A,A) fn, B default, {A} ls)
  @loop ((A | Void) a = void
         {A} = ls)
    tcase ls
      Void -> {default}
      Cons A -> tcase a
                  Void -> default : loop (ls.car,ls.cdr)
                  A -> b = ls.car
                       (a `fn` b) : loop (b,ls.cdr)

{E} ncircle ({E} ls)
  tcase ls
    Void -> error "Empty list"
    Cons E -> destroy last ls
                cdr = ls
              ls

{E} nconc ({{E}} lss)
  tcase lss
    Void -> void
    Cons E -> lss.car `nconc2` nconc lss.cdr

{E} nconc2 ({E} a, {E} b)
  tcase a
    Void -> void
    Cons E -> destroy last a
                cdr = b

{E} nreverse ({E} ls)
  tcase ls
    Void -> void
    Cons E -> @loop ({E} prev = ls
                     {E} cur = ls.cdr)
                tcase cur
                  Void -> prev
                  Cons E -> nxt = cur.cdr
                            loop (destroy cur
                                    cdr = prec
                                  nxt)

{E} nub ({E} ls)
  @loop ({E} acc = {}
         {E} ls = ls)
    tcase ls
      Void -> nreverse acc
      Cons E -> if ls.car `in` acc -> loop (acc, ls.cdr)
                   else -> loop (ls.car : acc, ls.cdr)

({E}, {E}) partition (Bool <- E fn, {E} ls)
  (filter (fn, ls)
   filter (not . fn, ls))

Bool ({E} a) `prefix` ({E} b)
  @loop ({E} a0 = a, {E} b0 = b)
    tcase a0
      Void   -> true
      Cons E -> tcase b0
                  Void   -> false
                  Cons E -> if a0.car == a1.car -> loop (a0.cdr, a1.cdr)
                               else -> a `prefix` b.cdr

{E} quicksort ({E} ls)
  tcase ls
    Void   -> void
    Cons E -> if null ls.cdr -> ls
                 else -> mid = ls.car
                         under = filter (ls, #1 < mid)
                         over  = filter (ls, #1 > mid)
                         quicksort under `nconc2` {mid} `nconc2` quicksort over

{E} repeat (E elt, Int n)
  if n <= 0 -> void
     else -> elt : repeat (elt, n - 1)

{E} reverse ({E} ls)
  foldl (#2 : #1, {}, #1)

{E} rplaca ({E} ls, E obj)
  tcase ls
    Cons E -> obj : ls.cdr
    Void -> error "Empty list"

{E} rplacd ({E} ls0, {E} ls1)
  tcase ls0
    Cons E -> modify ls0
                cdr : ls1
    Void -> error "Empty list"

({E}, {E}) span (Bool <- E fn, {E} ls)
  (takeWhile (fn, ls)
   dropWhile (fn, ls))

{E} tail ({E} ls)
  tcase ls
    Void   -> error "Didn't expect an empty list"
    Cons E -> ls.cdr

{E} take (Int n, {E} ls)
  if n <= 0 -> void
     true -> tcase ls
               Void   -> void
               Cons E -> ls.car : take (n - 1, ls.cdr)

{E} takeWhile (Bool <- E fn, {E} ls)
  tcase ls
    Void   -> void
    Cons E -> if fn ls.car -> ls.car : takeWhile (fn, ls.cdr)
                 true -> void

{E} unite ({{E}} lss)
  uniteOn (id,lss)

{E} uniteOn (A <- E fn, {{E}} lss)
  tcase lss
    Void -> {}
    Cons E -> if length lss == 1 -> lss.car
                 else -> @loop ({E} acc = {}
                                {E} ls = lss.car
                                {{E}} lss = lss.cdr)
                           tcase ls
                             Void -> tcase lss
                                       Void -> acc
                                       Cons E -> loop (acc,lss.car,lss.cdr
                             Cons E -> if E elt = ls.car
                                          member (fn elt,acc,fn) -> loop (acc,ls.cdr,lss)
                                          else -> loop (elt : acc,ls.cdr,lss)

({A},{B}) unzip ({(A,B)} ab)
  @loop ({A} a = {}
         {B} b = {}
         {(A,B)} ab = ab)
    tcase ab
      Void -> (nreverse a, nreverse b)
      Cons E -> cell = ab.car
                loop (1of2 cell : a
                      2of2 cell : b
                      ab.cdr)

{(A,B)} zip ({A} a, {B} b)
  tcase a
    Void -> void
    Cons E -> tcase b
                Void -> void
                Cons E -> (a.car,b.car) : zip (a.cdr,b.cdr)
