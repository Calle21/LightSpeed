Nova is a functional language

Types:

Types are created with the "type" keyword

type a = Int | Char

In this case a union between the types Int and Char is made and named "a".

Such unions will either be accompanied by a "tag", to specify which type is actually being used, or 

(Int, Int)

This is a tuple. Tuples are compound types

type Set LEAF = (Set LEAF left, leaf LEAF, Set LEAF right)

This is a type specification of a set. "LEAF" is a type variable, meaning it could be any type. Type variables are written with all upper case letters.

This set is a tuple of three. Which most sets are. 

Function definitions:

Int plusit Int a Int b
  a + b

Function definitions are C-stylish. To save typing and aid readability, neither parentheses or commas are necessary.

Automatic type inference is a feature of the language. The above definition could have been written as

plusit Int a Int b
  a + b

The compiler would infer that the return type is Int

(Types are always written with a capital letter in the beginning)

If statements:

If statements are special in Nova

Int biggestoftwo Int a Int b
  a > b ? a
  b

The predicate (any function returning a bool) is followed by a simple question mark.

Infix operators:

Functions can be defined as infix operators.

Int a + Int b = intermediate
                return a + b

Here we also see another feature in Nova. The ability the write "assembler" code, with the "intermediate" keyword.

Infix operators either contain just special characters, or is a normal name surrounded with back-quotes.

Int a `minus` Int b = intermediate
                      return a - b

Normal function names btw is simply a string of lower-case letters and numbers, containing at least one letter.

A function to test whether a string is a legal function name could be written as

Bool testname String a
  
