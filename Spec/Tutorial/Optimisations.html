<!DOCTYPE html>
<html>
        <head>
                <title>Optimizations</title>
                <link rel="stylesheet" href="../Style.css">
        </head>
        <body>
                <p>Since Nova is a purely functional programming language, some optimizations are necessary to make it run fast. Here are listed the mandatory optimizations.</p>
                <h3>Reuse of no-longer needed structures</h3>
                <p>This is a super important optimization. In other functional languages, Haskell for example, to update a single element in an array, the entire array has to be copied. This is obviously extremely inconvenient, and thus "functional" data structures, like the finger tree, has been invented to more efficiently handle sequences. However, in Nova, the compiler has to be able to figure out whether the old array is actually needed or not, after an update. And if in fact, the old array will not be needed, then the compiler has to reuse the old array. That is, rather than copying the entire array and changing one element, that one element will just be changed, as in any imperative language, and the old array will serve as the new array, in a purely functional manner. However, if the old array is still needed somehow, or can't be proven to not be needed in the future, then a copy of the array would have to be made.</p>
                <h3>Compile-time computation</h3>
                <p>Nova makes a distinction between pure and impure computations. A pure computation, called a function, is something which given the same arguments alway returns the same result, and does not have any side-effects. A Nova compiler is forced to execute calls to functions at compile-time when the arguments are known at compile time.</p>
                <h3>Tail-call recursion</h3>
                <p>Ofcourse. Tail-call recursion is an essential optimization for any functional language. Loops doesn't really exist. Instead recursion is used, and in order not to overflow the stack, and to make the code somewhat faster, tail-calls are transformed into simple jumps, rather than function calls.</p>
                <h3>Automatic stack allocation</h3>
                <p>Objects can be allocated in two places. On the stack and on the heap. Objects in the heap are garbage collected. This is very flexible but but somewhat time-consuming. Objects on the stack however are automatically discarded once the scope runs out. Some objects are only used within a limited scope, and when possible, the compiler is forced to allocate such objects on the stack, as to minimize the number of objects on the heap and make programs run faster and more memory-efficient.</p>
                <h3>Reuse of no longer needed variable space</h3>
                <p>This optimization is discussed in the 'More on variables' chapter.</p>
                <h3>Inlining of small computations</h3>
                <p>Function less than 3-4 machine-code instructions should be inlined when appropriate.</p>
                <p>Not the same as inlined functions discussed earlier. Maybe I should change the name of that.</p>
                <h3>Recursive accumulation</h3>
                <p>Consider a function to find the length of a list</p>
                <pre>
                Int length List E lst
                  null lst >> 0
                  1 + length lst.cdr
                </pre>
                <p>If the list is void, tested by the function 'null', then the length is obviously 0. Otherwise, it is obviously 1 + the length of the remainder of the list. It is considered that by writing a function the way I did above that it is not possible to avoid a recursive call, and thus start eating the stack. However, it is infact possible (I think) for the compiler to create an accumulator variable and avoid a recursive call, if the compiler knows before hand what the '+' function is doing. A general solution seems to be impossible, but for a handful of functions, it is probably possible. The most useful function would be the standard arithmetic functions, and also the 'cons' function (:).</p>
                <h3>Tuple embedment (not yet officially mandatory)</h3>
                <p>Suppose you have an array of tuples. Eahc tuple containing say three elements. The standard way to build this array would be to have an array of pointers, each pointing to a tuple. This would make access slower, yes, but if you were to copy a tuple from the array into another place, you'd only have to copy the pointer, and not the entire tuple. So copying would be faster. However, if you knew that you're not to need to copy the tuples, and you need fast access, then you might want to "embed" the tuples into the array, so that access gets faster. This could be implemented as a compiler directive. The difficulties to implement this feature weighted against the benefits has not yet been evaluated, so it is left as a possible optimisation, which could or could not become mandatory.</p>
                <h3>Junk-array copy (not yet officially mandatory)</h3>
                <p>Consider a map function that maps a function over an array. The result should be a new array with the results from the elements of the array given when applied to the function given (puh). Now, here is what it would look like</p>
                <pre>
                map B <- A fn [A] arr
                  @rec arr' = arr i = 0
                    i > len arr >> arr'
                    arr' ! i = fn (arr ! i)
                    rec arr' (i + 1)
                </pre>
                <p>The first thing to note is that a new array need not necessarily be allocated. The old array may infact be reused if it is not to be usedagain after the call to map. If a new array is needed however, a copy of the old array would be made during the first call to @rec. Afterwards, the new array would remain the same. However, it is not necessary to copy the whole array, since we will write over all the elements. A junk array would do fine. Is the compiler smart enough to see this, or would a statement by the programmer, to help the compiler, be more suitable? I don't know.</p>
        </body>
</html>
